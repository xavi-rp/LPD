---
title: "Land Productivity Dynamics Indicator: LPDynR package"
subtitle: "The name of the R package can/should be discussed!!!"

author:
  - Xavier Rotllan-Puig:
      email: xavi.rotllan.puig@gmail.com
      institute: [jrc, aster]
      correspondence: true
#  - Lorenzo:
#      institute: [jrc]
#  - Federico:
#      institute: [jrc]
  - Michael Cherlet:
      institute: [jrc]
 
institute:
  - jrc: Joint Research Centre
  - aster: ASTER-Projects


date: "`r format(Sys.time(), '%d/%m/%Y')`"

output: 
  word_document:
    reference_docx: LPD_MS_styles.docx
    #toc: true #table of content true
    toc_depth: 3  #up to three depths of headings (specified by #, ## and ###)
    #number_sections: true  #number sections at each table header
    #theme: united  #options for theme
    #highlight: tango  #syntax highlighting style
    #css: style.css   #custom css, should be in same folder. Only for HTML
    pandoc_args:
      - --lua-filter=scholar-metadata.lua
      - --lua-filter=author-info-blocks.lua
      
bibliography: lpd_biblio.bib
#csl: methods-in-ecology-and-evolution.csl
always_allow_html: yes

#abstract: |
#  **Introduction**: bla bla
#  **Material & Methods**: ble ble
#  **Results**: bli bli
#  **Discussion**: blo blo
#  **Conclusion**: blu blu
  

---


```{r setup, include = FALSE, results='asis'}
library(knitr)
library(pander)
library(captioner)
knitr::opts_chunk$set(echo = TRUE)

```

```{r include = FALSE}
if(Sys.info()[4] == "D01RI1700371"){
  source("E:\\rotllxa\\LPD\\LPD/00_settings.R")
}else if(Sys.info()[4] == "h05-wad.ies.jrc.it"){
  source("/home/rotllxa/LPD/LPD/00_settings.R")
}else if(Sys.info()[4] == "MacBook-MacBook-Pro-de-Xavier.local"){
  source("/Users/xavi_rp/Documents/D6_LPD/LPD/00_settings.R")
}

table_num <- captioner::captioner(prefix = "Table")
fig_num <- captioner::captioner(prefix = "Figure")
#ts <- 0
```





**Abstract**

[@ivits_assessing_2016]




# Introduction (Background)

```{r echo=FALSE}

tb1 <- table_num(name = "t1", caption = "bla bla bla")
 
```
 
`r table_num("t1", display = "cite")`

a) general introduction
UNCCD, SDG 15.3, Indicator

Beginning in the 1970s, the international community recognized that land degrada- tion/desertification was an economic, social, and environmental problem and began a process which ultimately resulted in the creation of the UN Convention to Combat Desertification (CCD). The convention defines desertification as land degradation in arid, semi-arid, and dry sub-humid areas resulting from various factors, including climatic variations and human activities (UNCCD 1994) [@Yengoh_2015]

[@Prince_2009]: Techniques for measurement of Net Primary Production (NPP) using Earth-observing satellite data were first developed in the mid 1980s

Accurate quantification of NPP at local to global scales is a central topic for carbon cycle, forest, land and ressource managers and politicians [@white_2000]

Reduced NPP is a consistent symptom of land degradation relative to the potential in the site [@Prince_2009]

Land degradation is measured through change in land productivity using, as a proxy, NPP, which is estimated through remotely sensed NDVI [@Yengoh_2015]

Land degradation can be caused by local human activities and biophysical pro- cesses as well as by activities and processes that are not tied to the local human or physical landscape, such as climate change [@Yengoh_2015]. 

Potential for the use of NDVI as a proxy for land productivity (one of the indicators of the state of land degradation) is based on numerous and rigorous studies that have identified a strong relationship between NDVI and NPP  [@Yengoh_2015, and references therein]

In detecting the status and trend of desertification, researchers have built on the relationship between NDVI and biomass productivity that has been well established in the literature [@Yengoh_2015, and references therein]

Changes in NPP or, rather, its proxy NDVI induced by land degradation can be measured using a range of remote sensing techniques so remote sensing has become an essential tool for global, regional, and national studies of land degradation [@Yengoh_2015] 


b) Land Productivity Dynamics Map: 

Include here a diagram of the whole process

```{r echo=FALSE}
fig0 <- fig_num(name = "f0", caption = "Flowchart of the process to calculate the Land-Productivity Dynamics indicator")
grph02 <- paste0(path2tempResults, "/graph02.png")
```





Phenological variables (Phenolo or others), Net Primary Productivity, etc (include here Eva's graph: Figure 3: Schematic representation of the main phenological and productivity variables calculated by Phenolo (reprint from Ivits et al., 2013a).)

Land Productivity Dynamics Map (`r fig_num("f0", display = "cite")`)= Long Term Change Map + Current Status Map of Land-Productivity


![`r fig0`](`r grph02`)


Qualitative indicator...




# Phenolo
Should this part be removed?? I think *Phenolo* should have its own document.
But if not, I keep it here for Lorenzo to fill it (???).





# Data set preparation

A case study is presented in this document in order to illustrate the methodology implemented in the *LPDynR* package to calculate the LPD indicator. So, in this case it is used a data set of `r length(vrbls_lst)` phenological and productivity-related variables, at global level and 1km of spatial resolution, obtained with *Phenolo*, a software developed at the EC-Joint Research Centre. *Phenolo* uses time series from different satellite sensors (NOAA, SPOT, etc.) and products (NDVI, fAPAR, etc.) to derive several ecosystem dynamism indicators [@ivits_ecosystem_2013]. In this case, the *Phenolo* products used to calculate the LPD map are `r paste0("*", paste0(vrbls_lst_names[-length(vrbls_lst_names)], collapse = "*, *"), "*", " and ", "*", vrbls_lst_names[length(vrbls_lst_names)], "*")`, and they have been derived from SPOT Vegetation NDVI of the period 1999-2012.

In the first version of *LPDynR* presented here, the main function uses multi-band "tiff" rasters to start the process, one per variable. Each band of each raster contains one of the years of the time series. Therefore, the initial data set needs to be prepared accordingly.



# Long-Term Change Map of Land-Productivity

As seen in `r fig_num("f0", display = "cite")` and explained above, the Land Productivity Dynamics indicator is produced based in two different main layers. The first one is the Long-Term Change Map, which incorporates information both on the progression of the general process of land degradation (positive or negative) and on the original level of productivity of the ecosystem, as well as whether it has changed its state or not in the period of study [@Ivits_report_2013]. This is necessary because, for instance, even though an ecosystem presents a long term negative dynamics, it might have not been strong enough to decrease its level of productivity to change its original state. The way in which these three sources of information are calculated for the LPD indicator using the standing biomass variable (i.e. SB) produced by *Penolo* are described in the following subsections. Standing biomass, or the yearly integration of all observed above ground biomass, can be used as a good approximation of the gross primary production of each spatial unit [GPP; @ivits_ecosystem_2013].


## Steadiness Index

```{r echo=FALSE}
fig1 <- fig_num(name = "f1", caption = "ble ble ble")
slp_rstr <- paste0(path2saveTests, "/slope_rstr.jpg")
```


`r fig_num("f1", display = "cite")`

![`r fig1`](`r slp_rstr`)






## Combining Steadiness Index with Baseline Levels of Standing Biomass


## Standing Biomass State Change


## Land-Productivity Long Term Change Map

```{r echo=FALSE}
figLandProd_change <- fig_num(name = "figLandProd_change", caption = "blu blu blu")
LandProd_change <- paste0(path2saveTests, "/LandProd_change.jpg")
```


![`r figLandProd_change`](`r LandProd_change`)


# Current Status Map of Land-Productivity

The Land Productivity Dynamics indicator is composed by two base layers, as shown in `r fig_num("f0", display = "cite")`. After the long term productivity dynamics described previously, the second source of information needed is the current level of land productivity. For this purpose, a Local Net Scaling approach is implemented [@Prince_2009]. Such approach estimates, by means of Earth Observation imagery and remote sensing tools, the level of land productivity of each pixel relative to those neighbours with similar characteristics. Therefore, a first step has to be the derivation of homogeneous environmental units (i.e. Ecosystem Functional Types), which allow to estimate the potential level of productivity, or efficiency, of each pixel. 


## Ecosystem Functional Types (EFTs)
```{r echo=FALSE}
figMulticoll <- fig_num(name = "Multicoll", caption = "Dendrogram of groups of correlated variables. Multicollinearity cutoff set to r > |0.7|")
Multicoll_plot <- paste0(path2tempResults, "/vars_collinearity.jpg")

figScreePlot <- fig_num(name = "ScreePlot", caption = "“Scree plot” method used to calculate the optimal number of clusters. The “elbow” indicates where the quality of the model no longer improves substantially as the number of clusters (model complexity) increases")
ScreePlot_plot <- paste0(path2tempResults, "/optim_num_clusters.jpg")

figEFTs <- fig_num(name = "EFTs", caption = "Ecosystem Functional Types (EFTs) derived from phenological and productivity variables using the K-means clustering method")
EFTmap <- paste0(path2saveTests, "/clusters_EFTs.jpg")
```

The methodology implemented to derive the Ecosystem Functional Types (EFTs) is basically a clustering process, using in this case phenological and productivity variables. Among the different unsupervised clustering techniques available for data grouping, K-means has been chosen. K-means is widely used in data science mainly due to its relative simplicity. However, as for the other iterative clustering algorithms based on minimum distance among similar data points, it’s recommended to standardize the data. Therefore, a three-steps process has been implemented to prepare the data to be clustered: (1) the `r length(vrbls_lst)` phenological and productivity-related variables are checked against multicollinearity, removing those highly correlated (|r| > 0.7); (2) a first Principal Component Analysis ("screening PCA") with the less-correlated variables is run in order to know the optimal number of variables to be used in a subsequent PCA, as well as the phenological variable most associated to those Principal Components (PCs); and (3) a "final PCA" is run with the results of the step 2 (i.e. number of PC axes and their most associated variables). After that, the K-means clustering algorithm is applied to the rotated components of the final PCA instead of to the phenological variables because the former are normalized with zero mean and 1 SD [@Ivits_report_2013].

In order to check for multicollinearity among the variables, their average is calculated taking advantage of the parallelization tools (i.e. package *parallel*). Then, the process is run using the function *removeCollinearity()*, from the package *virtualspecies*. This function allows the user to set up the minimum Pearson's correlation absolute value, which in this case is established to be 0.7 as default. It is also allowed to use a subset of random points of the data set to calculate the correlation. The default has been set to 10^6^ to speed up the process. Finally, the user can also choose to randomly select one of the variables of each group of correlation. `r fig_num("Multicoll", display = "cite")` shows a dendrogram to visualize the groups of intercorrelated variables in the present case study. The main part of the code is as follows:

```r
vrbles_NoC <- virtualspecies::removeCollinearity(stack_rstrs_avg, multicollinearity.cutoff = 0.70, select.variables = TRUE, sample.points = TRUE, nb.points = 1000000, plot = TRUE)

dev.copy(jpeg, paste0(path2tempResults, "/vars_collinearity.jpg"))
dev.off() 
```
\n

![`r figMulticoll`](`r Multicoll_plot`)

The next step is to run the first "screening PCA", which is automatically done over the uncorrelated variables. In order to know the optimal number of variables to be used in the subsequent PCA (i.e. "final PCA"), a threshold of cumulative variance of the PCs is implemented. This threshold is established to be 0.9. The main parts of the code for running both the "screening PCA" and the "final PCA" are the following, respectively:

```r
# Running the "screening PCA"
pca <- prcomp(na.omit(stack_rstrs_avg_noC_df), 
              retx = TRUE,   # to return rotated variables 
              center = TRUE, # variables are zero centered 
              scale. = TRUE  # scaling variables to have unit variance
              )
              
# Rotating the loadings to clearly associate one variable to each PC
pca.rotated <- varimax(pca$rotation, normalize = TRUE)

# Selecting "useful" PCs/variables
pca_importance <- summary(pca)
pca_importance <- as.data.frame(pca_importance)
cumul_varnce_threshold <- 0.9  # Threshold of cumulative variance used to select the number of useful PCs
usefulPCs <- which(pca_importance[3 ,] >= cumul_varnce_threshold)[1]
pca_importance <- pca_importance[, 1:usefulPCs]
if(nPCs > ncol(pca_importance)) nPCs <- ncol(pca_importance)
screeningPCA_variables_df <- pca.rotated$loadings
screeningPCA_variables_df <- as.data.frame(unclass(screeningPCA_variables_df))
screeningPCA_variables_df <- round(screeningPCA_variables_df, 0)[, c(1:nPCs)]
screeningPCA_variables <- names(which(apply(screeningPCA_variables_df, 1, sum) != 0))
```
\n


```r
#Performing the "final PCA"
stack_rstrs_avg_noC_df_final <- stack_rstrs_avg_noC_df[, names(stack_rstrs_avg_noC_df) %in% screeningPCA_variables]
pca_final <- prcomp(na.omit(stack_rstrs_avg_noC_df_final),
                    retx = TRUE, 
                    center = TRUE, # variables are zero centered 
                    scale. = TRUE  # scaling variables to have unit variance
                    )   
```
\n


Finally, the clustering algorithm is implemented over the selected PCs using the function *kmeans()* from the package *stats*. K-means is an iterative, unsupervised, method which has as one of the main limitations the fact that it is not able to optimize the number of clusters by itself, insted, it needs to be done externally. In this case, the optimal number of clusters was calculated to be around 20, using the “scree-plot method". Such method is based on running several K-means clustering with different number of clusters each, in order to assess how the quality of the models change with the number of clusters. Then, a plot is made with the results and an “elbow” indicates where the quality of the model no longer improves substantially as the number of clusters (model complexity) increases. See `r fig_num("ScreePlot", display = "cite")` for the results of this assessment.


![`r figScreePlot`](`r ScreePlot_plot`)


The “scree plot” method implemented in this study, undoubtedly has some level of subjectivity, as the user decides where the curve flattens enough. However, there exists several numerical methods to calculate the optimal number of clusters that remove such subjectivity, but which take also some statistical assumptions. They could be explored in the future if a higher level of accuracy is believed as necessary or if the whole process wants to be done without user's intervention.

This is the main part of the code to perform the "scree-plot method". Notice that the clustering is run with nine different number of clusters to give a good amount of points to plot the curve. And also that the maximum number of iterations is set up to 10, although it is unlikely that the process gets any convergence with such a low number of iterations.

```r
wss <- (nrow(pca_data_ini) - 1) * sum(apply(pca_data_ini[, - c(length(pca_data_ini))], 2, var))
num_clstrs <- c(5, 10, 15, 20, 25, 30, 40, 50, 60)
for (i in 2:(length(num_clstrs) + 1)) wss[i] <- kmeans(pca_data_ini[, - c(length(pca_data_ini))], centers = num_clstrs[i - 1], nstart = 1, iter.max = 10,algorithm = "MacQueen")$tot.withinss

jpeg(paste0(path2tempResults, "/optim_num_clusters.jpg"))
plot(c(1, num_clstrs), wss, type = "b", 
     xlab = "Number of Clusters",
     ylab = "Within groups sum of squares")
dev.off() 

```
\n


Then, with the optimal number of clusters decided, the K-means is run again. As previous tests of K-means with up to 100 iterations were not converging, the maximum number of iterations is set to 500 as default. Within this limit, for all the tests performed, the process always did achieve convergence. 

The very last step is to assign spatial information to the results of the K-means clustering. The EFTs resulted from the whole process can be seen in `r fig_num("EFTs", display = "cite")`, as well as the main lines of code of this section, which can bee seen below:


```r
# Running clustering
kmeans_clustring <- kmeans(pca_data_ini[, - c(length(pca_data_ini))], 
                           centers = 20, 
                           iter.max = 500,  
                           nstart = 1,
                           algorithm = "MacQueen"
                           )
                           
# Assigning spatial information
pca_data_ini$clstr <- kmeans_clustring$cluster
pca_data_ini <- pca_data_ini[, names(pca_data_ini) %in% c("clstr", "rn")]
all_data <- bind_rows(pca_data_ini, pca_data_ini_NA)
all_data <- all_data[order(all_data$rn), ]
pca_final_raster <- raster(paste0(path2tempResults, "/pca_final_raster.tif"))
xtnt <- extent(pca_final_raster)
pca_final_clstrs_raster <- raster(nrows = pca_final_raster@nrows, 
                                  ncols = pca_final_raster@ncols,
                                  crs = crs(pca_final_raster), 
                                  ext = xtnt, 
                                  vals = all_data$clstr)
names(pca_final_clstrs_raster) <- "clusterNum"

```
\n


![`r figEFTs`](`r EFTmap`)




## Local Net Production Scaling

```{r echo=FALSE}
figLocNetProd <- fig_num(name = "LocNetProd", caption = "Local Net Primary Production Scaling (LNS): proportion of annual production (i.e. average of 5 years of Cyclic Fraction) over the local potential production (i.e. the 90-percentile within the Ecosystem Functional Type)")
LocNetProd <- paste0(path2saveTests, "/LocalNetProductivity_LSP.jpg")
```

The Local Net Primary Production Scaling (from now on, Local Net Scaling or LNS) method [@Prince_2009] is based on the use of multi-temporal satellite data to calculate the difference between the potential and actual NPP for each pixel in homogeneous land areas. It will be considered potential productivity that productivity which would have been were it not for human factors, and it is estimated as the maximum value of productivity within each EFT [@Prince_2009, and references therein]. The current land production related to the local potential reflects the current level of productivity efficiency and, therefore, it is useful for the delineation of a productivity status map [@Ivits_report_2013]. 

Cyclic Fraction, or the summed NDVI over the growing season, is widely used as a proxy for the estimation of the current land productivity [@Fensholt_2013], as it incorporates both natural and anthropogenic factors which define the inter-annual variability of land production. Therefore, it represents that part of the Standing Biomass which is potentially appropriated to be used by humans and the environment [@Ivits_report_2013].  

In the case study, the Cyclic Fraction was derived from *Phenolo* for the period between 1999 and 2012, and each pixel subsequently averaged. That period coincides with the last five years of the time series used for the generation of the Long Term Change Map. The computation process for averaging was done again using parallelization, as seen in the following code:

```r
beginCluster(cors2use)   # it uses 'cors2use' cores for parallelizing
yrs <- (nlayers(CycleFraction_rstr) - 4):nlayers(CycleFraction_rstr)
CycleFraction_rstr_average <- clusterR(CycleFraction_rstr, calc, args = list(fun = mean_years_function), export = "yrs")
endCluster()
```
\n

Then, the potential productivity within each EFT was calculated. However, instead of the maximum value, its 90 percentile was established as the final potential, given that values higher than this threshold were considered as outliers. 

Finally, the Local Net Scaling per pixel was calculated as the proportion of its annual production (i.e. the average of 5 years Cyclic Fraction) over the potential production within its EFT (i.e. the 90 percentile). The result, shown in `r fig_num("LocNetProd", display = "cite")`, was expressed in percentage and was computed as follows: 
&nbsp;
```r
CycleFraction_average_df$LSP <- round(((CycleFraction_average_df$CyclicFraction / CycleFraction_average_df$CyclicFraction_90perc) * 100), 1)
```
&nbsp;

![`r figLocNetProd`](`r LocNetProd`)


For the calculation of the final LPD indicator, these levels of local productivity were aggregated into two categories, i.e, pixels with less than 50% of the highest annual local production (within the EFT) and pixels with more or equal to 50% of annual local production.



# Combined Assessment of Land-Productivity
`r # # Long Term Change Map + Current Status Map of Land-Productivity`
```{r echo=FALSE}
figCombAss <- fig_num(name = "figCombAss", caption = "Land-Productivity Dynamics indicator final map. Combined assessment of the Long-Term Channge Map of standing biomass and the Current Status Map of Land-Productivity based on the cyclic fraction")
LPD_CombinedAssessment <- paste0(path2saveTests, "/LPD_CombinedAssessment.jpg")

LookUpCombAss_categs <- "'d', Declining L-P; 'ew', Early signs of decline L-P; 'nf', Stable but stressed L-P; 'pf', Stable, not stressed L-P; 'i', Increase L-P; 'si', Strong increase of L-P"

tabLookUpCombAss <- table_num(name = "tabLookUpCombAss", caption = paste0("Lookup table for the combination of the two branches assessment (i.e. Long-Term Channge Map of standing biomass and Current Status Map of Land-Productivity of cyclic fraction) to derive the Land-Productivity Dynamics categories (i.e. ", LookUpCombAss_categs, ")"))

LookUpCombAss <- as.data.frame(matrix(nrow = 22, ncol = 5,
                                      c(rep("st1", 9), rep("st2", 3), rep("st3", 3), rep("st4", 7),
                                        rep("lo", 3), rep("me", 3), rep("hi", 3), "lo", "me", "hi", "lo", "me", "hi", rep("lo", 3), rep("me", 3), "hi",
                                        rep(c(0, 1, 2), 3), rep(0, 6), rep(c(0, 1, 2), 2), 0,
                                        rep("d", 6), "ew", rep("d", 2), rep("nf", 3), rep("pf", 5), "i", "pf", rep("i", 3),
                                        "ew", "ew", "d", "ew", "ew", "d", "nf", "ew", "ew", rep("nf", 3), rep("pf", 3), "i", "i", "si", "i", "i", "si", "si")))
LookUpCombAss <- rbind(as.data.frame(matrix(c(rep("", 3), "< 50%", ">= 50%"), nrow = 1, ncol = 5)), LookUpCombAss)
LookUpCombAss <- rbind(as.data.frame(matrix(c("Steadiness I.", "Baseline L.", "State Change", "", "Local Sc."), nrow = 1, ncol = 5)), LookUpCombAss)
#names(LookUpCombAss) <- c("Steadiness I.", "Baseline L.", "State Change < 50%", "Local Sc.  >= 50%", "Local Sc.")
names(LookUpCombAss) <- c("Steadiness I.", "Baseline L.", "State Change", "Local Sc.", "Local Sc.")
```


The Land-Productivity Dynamics indicator final map (`r fig_num("figCombAss", display = "cite")`) is the result of the combined assessment of the Long-Term Change Map (`r fig_num("figLandProd_change", display = "cite")`), based on the standing biomass, and the Current Status Map of Land-Productivity (`r fig_num("LocNetProd", display = "cite")`), based on the cyclic fraction and derived through the Local Net Scaling approach. See the flowchart of the process for the derivation of the indicator in `r fig_num("f0", display = "cite")`.

As seen above in this document, both branches to calculate the indicator are qualitative methods. Therefore, the final LPD indicator is also a qualitative measure with 6 possible values or categories after the reclassification of each pixel as shown in the lookup table (`r table_num("tabLookUpCombAss", display = "cite")`). Such categories are `r LookUpCombAss_categs`.


`r table_num("tabLookUpCombAss", display = "full")`
```{r echo=FALSE}
#pander(splittable(LookUpCombAss, 2))
#emphasize.strong.cells(which(LookUpCombAss$`Local Scaling < 50%` %in% c("d", "ew", "nf", "pf")))
emphasize.strong.cells(which(LookUpCombAss == "d" | 
                             LookUpCombAss == "ew" |
                             LookUpCombAss == "nf" |
                             LookUpCombAss == "pf" |
                             LookUpCombAss == "i" |
                             LookUpCombAss == "si", arr.ind = TRUE))
names(LookUpCombAss) <- NULL
pander(LookUpCombAss)



```
&nbsp;

![`r figCombAss`](`r LPD_CombinedAssessment`)



# Conclusions

According to the flowchart presented at the beginning of this document (`r fig_num("f0", display = "cite")`), the Land-Productivity Dynamics indicator (LPD) is derived from several phenological and productivity variables, in turn, obtained from time series of earth observation imagery.


# References

